<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fileagent.all_included API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fileagent.all_included</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fileagent.all_included.FileAgent"><code class="flex name class">
<span>class <span class="ident">FileAgent</span></span>
<span>(</span><span>port: int = None, host: str = None, directory: str = None, file: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileAgent:
    def __init__(
        self,
        port: int = None,
        host: str = None,
        directory: str = None,
        file: str = None,
    ):

        self.default_values(port, host, directory, file)

        self.app = FastAPI()
        # This should change to correlate with the arguments passed

        self.internal_path = Path(__file__).parent.parent
        # For non docker usage
        self.internal_path = Path(self.internal_path.parent, &#34;snort&#34;, &#34;volumes&#34;)

        self.data_path = Path(self.internal_path, &#34;custom&#34;)
        self.data_backup_path = Path(self.data_path, &#34;backup&#34;)
        self.rules_file = Path(self.data_path, self.args.file)

        self.setup_routes()

    def set_arguments(self):
        &#34;&#34;&#34;
        Description:
            Set the arguments for the agent, and save the important information as attributes of the class
        &#34;&#34;&#34;

        self.parser = argparse.ArgumentParser()
        self.parser.add_argument(
            &#34;-p&#34;,
            &#34;--port&#34;,
            type=int,
            default=8000,
            help=&#34;Port to run the fastapi server on&#34;,
        )

        self.parser.add_argument(
            &#34;--host&#34;,
            type=str,
            default=&#34;0.0.0.0&#34;,
            help=&#34;Host of the fastapi server&#34;,
        )

        self.parser.add_argument(
            &#34;-f&#34;,
            &#34;--file&#34;,
            type=str,
            default=None,
            help=&#34;Path to the file&#34;,
        )

        self.parser.add_argument(
            &#34;-d&#34;,
            &#34;--directory&#34;,
            type=str,
            default=None,
            help=&#34;Path to the data directory&#34;,
        )

    def assign_attributes(self, attributes):
        &#34;&#34;&#34;
        Assign attributes dynamically based on provided arguments or defaults.

        Args:
            attributes (dict): A dictionary where keys are attribute names and values are tuples
                            of (provided_value, default_value).
        &#34;&#34;&#34;
        for attr, (provided_value, default_value) in attributes.items():
            setattr(
                self,
                attr,
                provided_value if provided_value is not None else default_value,
            )

    def default_values(self, port: int, host: str, directory: str, file: str):
        &#34;&#34;&#34;
        Description:
            This function is meant to be run by the init function of the class
            Set the default values for the agent
            This function sets the default values for the agent. It checks if the arguments passed to the Class are None, and calls the arguments from argparse.
            If the arguments are not None, it assigns the values to the attribute of the class.
            If the directory is None, it sets the directory to the parent of the file.
            It also checks if the file is None, and raises a ValueError if it is.

        Args:
            port (int): Port to run the fastapi server on
            host (str): Host of the fastapi server
            directory (str): Path to the data directory
            file (str): Path to the file

        Raises:
            ValueError: File name is required
        &#34;&#34;&#34;

        if any([arg is None for arg in [port, host, directory, file]]):
            self.set_arguments()
            self.args = self.parser.parse_args()

        attributes = {
            &#34;port&#34;: (port, self.args.port),
            &#34;host&#34;: (host, self.args.host),
            &#34;directory&#34;: (directory, self.args.directory),
            &#34;file&#34;: (file, self.args.file),
        }

        self.assign_attributes(attributes)

        if self.file is None:
            raise ValueError(&#34;File name is required&#34;)

        if self.directory is None:
            self.directory = Path(__file__).parent

    def setup_routes(self):
        &#34;&#34;&#34;
        Description:
            Setup the routes for the agent

        Raises:
            HTTPException:
            HTTPException: _description_
            HTTPException: _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;

        @self.app.post(&#34;/upload&#34;)
        async def upload_json(file: UploadFile = File(...)):
            if not file:
                raise HTTPException(
                    status_code=400, detail=&#34;No file part in the request&#34;
                )

            if file.filename == &#34;&#34;:
                raise HTTPException(status_code=400, detail=&#34;No file selected&#34;)

            content = await file.read()
            content_str = content.decode(&#34;utf-8&#34;)

            if file.content_type == &#34;application/json&#34;:
                self.append_rule(
                    {&#34;content_type&#34;: &#34;application/json&#34;, &#34;content&#34;: content_str}
                )
                return {&#34;message&#34;: &#34;JSON file received&#34;, &#34;content&#34;: content_str}
            elif file.content_type == &#34;text/plain&#34;:
                self.append_rule({&#34;content_type&#34;: &#34;text/plain&#34;, &#34;content&#34;: content_str})
                return {&#34;message&#34;: &#34;Text file received&#34;, &#34;content&#34;: content_str}
            else:
                raise HTTPException(status_code=400, detail=&#34;Unsupported file type&#34;)

    def ip_matches(self, data: str) -&gt; str:
        &#34;&#34;&#34;
        Description:
            Check if the data contains an ip address. Checks for ipv4, ipv6 and url

        Args:
            data (str): Data to be checked for ip address

        Returns:
            str: the ip/url regex matching case
        &#34;&#34;&#34;
        ipv4_pattern = r&#34;\b(?:\d{1,3}\.){3}\d{1,3}\b&#34;
        ipv6_pattern = r&#34;\b(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}\b&#34;
        url_pattern = r&#34;\bhttps?://[^\s/$.?#].[^\s]*\b&#34;

        for pattern in [ipv4_pattern, ipv6_pattern, url_pattern]:
            match = re.search(pattern, data)
            if match:
                return match.group(0)
        return None

    def get_ip_from_request(self, request: dict) -&gt; str:
        &#34;&#34;&#34;
        Description:
            Get the ip address from the request

        Args:
            request (dict): Request data to be checked for ip address

        Returns:
            str: The ip address from the request
        &#34;&#34;&#34;

        if request.get(&#34;content_type&#34;) == &#34;application/json&#34;:
            data = json.loads(request.get(&#34;content&#34;))
            return data.get(&#34;ip&#34;)
        elif request.get(&#34;content_type&#34;) == &#34;text/plain&#34;:
            return self.ip_matches(request.get(&#34;content&#34;))
        else:
            return None

    def rule_translator(self, data: dict) -&gt; str:
        &#34;&#34;&#34;
        Description:
            Translate the data into a rule
            Right now this is a simple implementation
            Checks if it is a json or text file and extracts the ip address

        Args:
            data (dict): Data from the post request to be translated into a rule,

        Returns:
            str: Rule to be appended to the rules file
        &#34;&#34;&#34;

        if ip := self.get_ip_from_request(data) is None:
            return

        rule = f&#34;&#34;&#34;alert ip {ip} any -&gt; $HOME_NET any (msg: &#34;IP Alert Incoming From IP: {ip}&#34;;   classtype:tcp-connection; sid:28154103; rev:1; reference:url,https://misp.gsma.com/events/view/19270;)&#34;&#34;&#34;

        return rule

    def append_rule(self, data):
        &#34;&#34;&#34;
        Description:
        Append rule to the local.rules

        Args:
            data (str): Data to be appended to the local.rules file
        &#34;&#34;&#34;

        # Right now this is just a simple implementation

        if rule := self.rule_translator(data) is None:
            return

        if self.rule_exists(rule):
            return

        print(f&#34;Appending rule: {rule}&#34;)
        # Backup the rules file
        self.file_backup()

        # Append the rule to the rules file
        with open(self.rules_file, &#34;a&#34;) as file:
            file.write(f&#34;\n{rule}\n&#34;)

    def rule_exists(self, rule):
        &#34;&#34;&#34;
        Description:
            Check if the rule already exists in the rules file
            This function reads the rules file line by line and determines if the
            provided rule is present in any of the lines. It is useful for avoiding
            duplicate entries in the rules file.

        Args:
            rule (str): Rule to be checked

        Returns:
            bool: True if the rule exists, False otherwise
        &#34;&#34;&#34;

        with open(self.rules_file, &#34;r&#34;) as file:
            rules = file.readlines()
            if any(rule in rule_line for rule_line in rules):
                return True
            return False

    def file_backup(self):
        &#34;&#34;&#34;
        Description:
            -----------

            Creates a backup of the rules file in the specified backup directory.
            This method ensures that the backup directory exists, then creates a backup
            of the `self.rules_file` by copying its contents to a new file in the backup
            directory. The backup file is named using the original file&#39;s stem and the
            current timestamp in the format &#39;YYYY-MM-DD_HH-MM-SS.bak&#39;.
            Steps:
            1. Ensures the backup directory (`self.data_backup_path`) exists.
            2. Constructs the backup file path using the original file&#39;s stem and a timestamp.
            3. Reads the contents of the `self.rules_file`.
            4. Writes the contents to the newly created backup file.
            Raises:
                FileNotFoundError: If `self.rules_file` does not exist.
                IOError: If there is an issue reading from or writing to the files.
            Note:
                - The method assumes `self.rules_file` and `self.data_backup_path` are
                valid `Path` objects.
                - The timestamp ensures that each backup file has a unique name.

        Raises:
            FileNotFoundError: If `self.rules_file` does not exist.
            IOError: If there is an issue reading from or writing to the files.

        &#34;&#34;&#34;

        # Copy the self.rules_file to the backup directory with the name filename-time.bak
        # Ensure the backup directory exists
        self.data_backup_path.mkdir(parents=True, exist_ok=True)
        print(f&#34;Creating backup in {self.data_backup_path}&#34;)
        # Create the backup file path
        backup_file = Path(
            self.data_backup_path,
            f&#34;{self.rules_file.stem}-{datetime.datetime.now().strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;)}.bak&#34;,
        )
        with open(self.rules_file, &#34;r&#34;) as file:
            rules = file.readlines()

            with open(backup_file, &#34;w&#34;) as file:
                file.writelines(rules)

    def main(self):
        &#34;&#34;&#34;
        Description
        -----------
        Main function to run the agent

        Parameters
        ----------
        None
        &#34;&#34;&#34;
        uvicorn.run(self.app, host=self.host, port=self.port)</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="fileagent.all_included.FileAgent.append_rule"><code class="name flex">
<span>def <span class="ident">append_rule</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_rule(self, data):
    &#34;&#34;&#34;
    Description:
    Append rule to the local.rules

    Args:
        data (str): Data to be appended to the local.rules file
    &#34;&#34;&#34;

    # Right now this is just a simple implementation

    if rule := self.rule_translator(data) is None:
        return

    if self.rule_exists(rule):
        return

    print(f&#34;Appending rule: {rule}&#34;)
    # Backup the rules file
    self.file_backup()

    # Append the rule to the rules file
    with open(self.rules_file, &#34;a&#34;) as file:
        file.write(f&#34;\n{rule}\n&#34;)</code></pre>
</details>
<div class="desc"><p>Description:
Append rule to the local.rules</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>Data to be appended to the local.rules file</dd>
</dl></div>
</dd>
<dt id="fileagent.all_included.FileAgent.assign_attributes"><code class="name flex">
<span>def <span class="ident">assign_attributes</span></span>(<span>self, attributes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_attributes(self, attributes):
    &#34;&#34;&#34;
    Assign attributes dynamically based on provided arguments or defaults.

    Args:
        attributes (dict): A dictionary where keys are attribute names and values are tuples
                        of (provided_value, default_value).
    &#34;&#34;&#34;
    for attr, (provided_value, default_value) in attributes.items():
        setattr(
            self,
            attr,
            provided_value if provided_value is not None else default_value,
        )</code></pre>
</details>
<div class="desc"><p>Assign attributes dynamically based on provided arguments or defaults.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attributes</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary where keys are attribute names and values are tuples
of (provided_value, default_value).</dd>
</dl></div>
</dd>
<dt id="fileagent.all_included.FileAgent.default_values"><code class="name flex">
<span>def <span class="ident">default_values</span></span>(<span>self, port: int, host: str, directory: str, file: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_values(self, port: int, host: str, directory: str, file: str):
    &#34;&#34;&#34;
    Description:
        This function is meant to be run by the init function of the class
        Set the default values for the agent
        This function sets the default values for the agent. It checks if the arguments passed to the Class are None, and calls the arguments from argparse.
        If the arguments are not None, it assigns the values to the attribute of the class.
        If the directory is None, it sets the directory to the parent of the file.
        It also checks if the file is None, and raises a ValueError if it is.

    Args:
        port (int): Port to run the fastapi server on
        host (str): Host of the fastapi server
        directory (str): Path to the data directory
        file (str): Path to the file

    Raises:
        ValueError: File name is required
    &#34;&#34;&#34;

    if any([arg is None for arg in [port, host, directory, file]]):
        self.set_arguments()
        self.args = self.parser.parse_args()

    attributes = {
        &#34;port&#34;: (port, self.args.port),
        &#34;host&#34;: (host, self.args.host),
        &#34;directory&#34;: (directory, self.args.directory),
        &#34;file&#34;: (file, self.args.file),
    }

    self.assign_attributes(attributes)

    if self.file is None:
        raise ValueError(&#34;File name is required&#34;)

    if self.directory is None:
        self.directory = Path(__file__).parent</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>This function is meant to be run by the init function of the class
Set the default values for the agent
This function sets the default values for the agent. It checks if the arguments passed to the Class are None, and calls the arguments from argparse.
If the arguments are not None, it assigns the values to the attribute of the class.
If the directory is None, it sets the directory to the parent of the file.
It also checks if the file is None, and raises a ValueError if it is.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>Port to run the fastapi server on</dd>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>Host of the fastapi server</dd>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the data directory</dd>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the file</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>File name is required</dd>
</dl></div>
</dd>
<dt id="fileagent.all_included.FileAgent.file_backup"><code class="name flex">
<span>def <span class="ident">file_backup</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_backup(self):
    &#34;&#34;&#34;
    Description:
        -----------

        Creates a backup of the rules file in the specified backup directory.
        This method ensures that the backup directory exists, then creates a backup
        of the `self.rules_file` by copying its contents to a new file in the backup
        directory. The backup file is named using the original file&#39;s stem and the
        current timestamp in the format &#39;YYYY-MM-DD_HH-MM-SS.bak&#39;.
        Steps:
        1. Ensures the backup directory (`self.data_backup_path`) exists.
        2. Constructs the backup file path using the original file&#39;s stem and a timestamp.
        3. Reads the contents of the `self.rules_file`.
        4. Writes the contents to the newly created backup file.
        Raises:
            FileNotFoundError: If `self.rules_file` does not exist.
            IOError: If there is an issue reading from or writing to the files.
        Note:
            - The method assumes `self.rules_file` and `self.data_backup_path` are
            valid `Path` objects.
            - The timestamp ensures that each backup file has a unique name.

    Raises:
        FileNotFoundError: If `self.rules_file` does not exist.
        IOError: If there is an issue reading from or writing to the files.

    &#34;&#34;&#34;

    # Copy the self.rules_file to the backup directory with the name filename-time.bak
    # Ensure the backup directory exists
    self.data_backup_path.mkdir(parents=True, exist_ok=True)
    print(f&#34;Creating backup in {self.data_backup_path}&#34;)
    # Create the backup file path
    backup_file = Path(
        self.data_backup_path,
        f&#34;{self.rules_file.stem}-{datetime.datetime.now().strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;)}.bak&#34;,
    )
    with open(self.rules_file, &#34;r&#34;) as file:
        rules = file.readlines()

        with open(backup_file, &#34;w&#34;) as file:
            file.writelines(rules)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<hr>
<p>Creates a backup of the rules file in the specified backup directory.
This method ensures that the backup directory exists, then creates a backup
of the <code>self.rules_file</code> by copying its contents to a new file in the backup
directory. The backup file is named using the original file's stem and the
current timestamp in the format 'YYYY-MM-DD_HH-MM-SS.bak'.
Steps:
1. Ensures the backup directory (<code>self.data_backup_path</code>) exists.
2. Constructs the backup file path using the original file's stem and a timestamp.
3. Reads the contents of the <code>self.rules_file</code>.
4. Writes the contents to the newly created backup file.
Raises:
FileNotFoundError: If <code>self.rules_file</code> does not exist.
IOError: If there is an issue reading from or writing to the files.
Note:
- The method assumes <code>self.rules_file</code> and <code>self.data_backup_path</code> are
valid <code>Path</code> objects.
- The timestamp ensures that each backup file has a unique name.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If <code>self.rules_file</code> does not exist.</dd>
<dt><code>IOError</code></dt>
<dd>If there is an issue reading from or writing to the files.</dd>
</dl></div>
</dd>
<dt id="fileagent.all_included.FileAgent.get_ip_from_request"><code class="name flex">
<span>def <span class="ident">get_ip_from_request</span></span>(<span>self, request: dict) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ip_from_request(self, request: dict) -&gt; str:
    &#34;&#34;&#34;
    Description:
        Get the ip address from the request

    Args:
        request (dict): Request data to be checked for ip address

    Returns:
        str: The ip address from the request
    &#34;&#34;&#34;

    if request.get(&#34;content_type&#34;) == &#34;application/json&#34;:
        data = json.loads(request.get(&#34;content&#34;))
        return data.get(&#34;ip&#34;)
    elif request.get(&#34;content_type&#34;) == &#34;text/plain&#34;:
        return self.ip_matches(request.get(&#34;content&#34;))
    else:
        return None</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Get the ip address from the request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>dict</code></dt>
<dd>Request data to be checked for ip address</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The ip address from the request</dd>
</dl></div>
</dd>
<dt id="fileagent.all_included.FileAgent.ip_matches"><code class="name flex">
<span>def <span class="ident">ip_matches</span></span>(<span>self, data: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ip_matches(self, data: str) -&gt; str:
    &#34;&#34;&#34;
    Description:
        Check if the data contains an ip address. Checks for ipv4, ipv6 and url

    Args:
        data (str): Data to be checked for ip address

    Returns:
        str: the ip/url regex matching case
    &#34;&#34;&#34;
    ipv4_pattern = r&#34;\b(?:\d{1,3}\.){3}\d{1,3}\b&#34;
    ipv6_pattern = r&#34;\b(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}\b&#34;
    url_pattern = r&#34;\bhttps?://[^\s/$.?#].[^\s]*\b&#34;

    for pattern in [ipv4_pattern, ipv6_pattern, url_pattern]:
        match = re.search(pattern, data)
        if match:
            return match.group(0)
    return None</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Check if the data contains an ip address. Checks for ipv4, ipv6 and url</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>Data to be checked for ip address</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the ip/url regex matching case</dd>
</dl></div>
</dd>
<dt id="fileagent.all_included.FileAgent.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self):
    &#34;&#34;&#34;
    Description
    -----------
    Main function to run the agent

    Parameters
    ----------
    None
    &#34;&#34;&#34;
    uvicorn.run(self.app, host=self.host, port=self.port)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Main function to run the agent</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>None</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="fileagent.all_included.FileAgent.rule_exists"><code class="name flex">
<span>def <span class="ident">rule_exists</span></span>(<span>self, rule)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rule_exists(self, rule):
    &#34;&#34;&#34;
    Description:
        Check if the rule already exists in the rules file
        This function reads the rules file line by line and determines if the
        provided rule is present in any of the lines. It is useful for avoiding
        duplicate entries in the rules file.

    Args:
        rule (str): Rule to be checked

    Returns:
        bool: True if the rule exists, False otherwise
    &#34;&#34;&#34;

    with open(self.rules_file, &#34;r&#34;) as file:
        rules = file.readlines()
        if any(rule in rule_line for rule_line in rules):
            return True
        return False</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Check if the rule already exists in the rules file
This function reads the rules file line by line and determines if the
provided rule is present in any of the lines. It is useful for avoiding
duplicate entries in the rules file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rule</code></strong> :&ensp;<code>str</code></dt>
<dd>Rule to be checked</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the rule exists, False otherwise</dd>
</dl></div>
</dd>
<dt id="fileagent.all_included.FileAgent.rule_translator"><code class="name flex">
<span>def <span class="ident">rule_translator</span></span>(<span>self, data: dict) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rule_translator(self, data: dict) -&gt; str:
    &#34;&#34;&#34;
    Description:
        Translate the data into a rule
        Right now this is a simple implementation
        Checks if it is a json or text file and extracts the ip address

    Args:
        data (dict): Data from the post request to be translated into a rule,

    Returns:
        str: Rule to be appended to the rules file
    &#34;&#34;&#34;

    if ip := self.get_ip_from_request(data) is None:
        return

    rule = f&#34;&#34;&#34;alert ip {ip} any -&gt; $HOME_NET any (msg: &#34;IP Alert Incoming From IP: {ip}&#34;;   classtype:tcp-connection; sid:28154103; rev:1; reference:url,https://misp.gsma.com/events/view/19270;)&#34;&#34;&#34;

    return rule</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Translate the data into a rule
Right now this is a simple implementation
Checks if it is a json or text file and extracts the ip address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Data from the post request to be translated into a rule,</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Rule to be appended to the rules file</dd>
</dl></div>
</dd>
<dt id="fileagent.all_included.FileAgent.set_arguments"><code class="name flex">
<span>def <span class="ident">set_arguments</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_arguments(self):
    &#34;&#34;&#34;
    Description:
        Set the arguments for the agent, and save the important information as attributes of the class
    &#34;&#34;&#34;

    self.parser = argparse.ArgumentParser()
    self.parser.add_argument(
        &#34;-p&#34;,
        &#34;--port&#34;,
        type=int,
        default=8000,
        help=&#34;Port to run the fastapi server on&#34;,
    )

    self.parser.add_argument(
        &#34;--host&#34;,
        type=str,
        default=&#34;0.0.0.0&#34;,
        help=&#34;Host of the fastapi server&#34;,
    )

    self.parser.add_argument(
        &#34;-f&#34;,
        &#34;--file&#34;,
        type=str,
        default=None,
        help=&#34;Path to the file&#34;,
    )

    self.parser.add_argument(
        &#34;-d&#34;,
        &#34;--directory&#34;,
        type=str,
        default=None,
        help=&#34;Path to the data directory&#34;,
    )</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Set the arguments for the agent, and save the important information as attributes of the class</p></div>
</dd>
<dt id="fileagent.all_included.FileAgent.setup_routes"><code class="name flex">
<span>def <span class="ident">setup_routes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_routes(self):
    &#34;&#34;&#34;
    Description:
        Setup the routes for the agent

    Raises:
        HTTPException:
        HTTPException: _description_
        HTTPException: _description_

    Returns:
        _type_: _description_
    &#34;&#34;&#34;

    @self.app.post(&#34;/upload&#34;)
    async def upload_json(file: UploadFile = File(...)):
        if not file:
            raise HTTPException(
                status_code=400, detail=&#34;No file part in the request&#34;
            )

        if file.filename == &#34;&#34;:
            raise HTTPException(status_code=400, detail=&#34;No file selected&#34;)

        content = await file.read()
        content_str = content.decode(&#34;utf-8&#34;)

        if file.content_type == &#34;application/json&#34;:
            self.append_rule(
                {&#34;content_type&#34;: &#34;application/json&#34;, &#34;content&#34;: content_str}
            )
            return {&#34;message&#34;: &#34;JSON file received&#34;, &#34;content&#34;: content_str}
        elif file.content_type == &#34;text/plain&#34;:
            self.append_rule({&#34;content_type&#34;: &#34;text/plain&#34;, &#34;content&#34;: content_str})
            return {&#34;message&#34;: &#34;Text file received&#34;, &#34;content&#34;: content_str}
        else:
            raise HTTPException(status_code=400, detail=&#34;Unsupported file type&#34;)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Setup the routes for the agent</p>
<h2 id="raises">Raises</h2>
<dl>
<dt>HTTPException:</dt>
<dt><code>HTTPException</code></dt>
<dd><em>description</em></dd>
<dt><code>HTTPException</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fileagent" href="index.html">fileagent</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fileagent.all_included.FileAgent" href="#fileagent.all_included.FileAgent">FileAgent</a></code></h4>
<ul class="two-column">
<li><code><a title="fileagent.all_included.FileAgent.append_rule" href="#fileagent.all_included.FileAgent.append_rule">append_rule</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.assign_attributes" href="#fileagent.all_included.FileAgent.assign_attributes">assign_attributes</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.default_values" href="#fileagent.all_included.FileAgent.default_values">default_values</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.file_backup" href="#fileagent.all_included.FileAgent.file_backup">file_backup</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.get_ip_from_request" href="#fileagent.all_included.FileAgent.get_ip_from_request">get_ip_from_request</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.ip_matches" href="#fileagent.all_included.FileAgent.ip_matches">ip_matches</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.main" href="#fileagent.all_included.FileAgent.main">main</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.rule_exists" href="#fileagent.all_included.FileAgent.rule_exists">rule_exists</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.rule_translator" href="#fileagent.all_included.FileAgent.rule_translator">rule_translator</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.set_arguments" href="#fileagent.all_included.FileAgent.set_arguments">set_arguments</a></code></li>
<li><code><a title="fileagent.all_included.FileAgent.setup_routes" href="#fileagent.all_included.FileAgent.setup_routes">setup_routes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
