<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>fileagent.managers.manager_snort API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fileagent.managers.manager_snort</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fileagent.managers.manager_snort.ManagerSnort"><code class="flex name class">
<span>class <span class="ident">ManagerSnort</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ManagerSnort:

    def ip_matches(self, data: str) -&gt; str:
        &#34;&#34;&#34;
        Description:
            Check if the data contains an ip address. Checks for ipv4, ipv6 and url

        Args:
            data (str): Data to be checked for ip address

        Returns:
            str: the ip/url regex matching case
        &#34;&#34;&#34;
        ipv4_pattern = r&#34;\b(?:\d{1,3}\.){3}\d{1,3}\b&#34;
        ipv6_pattern = r&#34;\b(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}\b&#34;
        url_pattern = r&#34;\bhttps?://[^\s/$.?#].[^\s]*\b&#34;

        for pattern in [ipv4_pattern, ipv6_pattern, url_pattern]:
            match = re.search(pattern, data)
            if match:
                return match.group(0)
        return None

    def get_ip_from_request(self, request: dict) -&gt; str:
        &#34;&#34;&#34;
        Description:
            Get the ip address from the request

        Args:
            request (dict): Request data to be checked for ip address

        Returns:
            str: The ip address from the request
        &#34;&#34;&#34;

        if request.get(&#34;content_type&#34;) == &#34;application/json&#34;:
            data = json.loads(request.get(&#34;content&#34;))
            return data.get(&#34;ip&#34;)
        elif request.get(&#34;content_type&#34;) == &#34;text/plain&#34;:
            return self.ip_matches(request.get(&#34;content&#34;))
        else:
            return None

    def rule_translator(self, data: dict) -&gt; str:
        &#34;&#34;&#34;
        Description:
            Translate the data into a rule
            Right now this is a simple implementation
            Checks if it is a json or text file and extracts the ip address

        Args:
            data (dict): Data from the post request to be translated into a rule,

        Returns:
            str: Rule to be appended to the rules file
        &#34;&#34;&#34;

        tranlator_book = {
            &#34;block_ip&#34;: self.building_rule_block,
            &#34;block_domain&#34;: self.building_rule_block_domain,
            &#34;alert_ip&#34;: self.building_rule_alert,
        }

        rule = None

        if (command := data.get(&#34;command&#34;)) in tranlator_book.keys():
            rule = tranlator_book[command](data.get(&#34;target&#34;))
        return rule

    def building_rule_block(self, target: str, msg: str = None, verbose=False) -&gt; str:
        rule = &#34;&#34;

        rule += f&#34;block &#34;  # Start of the rule
        rule += f&#34;http &#34;
        rule += f&#34;{target} &#34;
        rule += &#34;any -&gt; $HOME_NET any &#34;  # Direction of the alert
        rule += &#34;(&#34;

        if msg:
            rule += f&#39;msg:&#34;{msg}&#34;; &#39;  # Message of the alert
        else:
            rule += f&#39;msg:&#34;Block traffic From IP {target}&#34;; &#39;
        rule += &#34;)&#34;
        if verbose:
            print(rule)
        return rule

    def building_rule_block_domain(
        self, domain: str, msg: str = None, verbose=False
    ) -&gt; str:
        rule = &#34;&#34;
        rule += f&#34;block &#34;  # Start of the rule
        rule += &#34;ssl &#34;  # Protocol of the rule
        rule += &#34;any &#34;  # IP address of the rule
        rule += &#34;any &#34;  # Port of the rule
        rule += &#34;-&gt; &#34;  # Direction of the rule
        rule += &#34;$HOME_NET 443 &#34;  # Direction of the alert
        rule += &#34;(&#34;

        if msg:
            rule += f&#39;msg:&#34;{msg}&#34;; &#39;  # Message of the alert
        else:
            rule += f&#39;msg:&#34;Block domain {domain}&#34;; &#39;
        rule += f&#39;content:&#34;|{self.to_hex(domain)}|&#34;  ;&#39;  # Content of the alert
        rule += &#34;)&#34;

        if verbose:
            print(rule)
        return rule

    def building_rule_alert(self, target: str, msg: str = None, verbose=False) -&gt; str:
        rule = &#34;&#34;

        rule += f&#34;alert &#34;  # Start of the rule
        rule += &#34;ip &#34;
        rule += f&#34;{target} &#34;
        rule += &#34;any -&gt; $HOME_NET any &#34;  # Direction of the alert
        rule += &#34;(&#34;

        if msg:
            rule += f&#39;msg:&#34;{msg}&#34;; &#39;  # Message of the alert
        else:
            rule += f&#39;msg:&#34;IP Alert Incoming From IP {target}&#34;; &#39;

        rule += &#34;classtype:tcp-connection; &#34;  # Class type of the alert
        rule += &#34;sid:28154103; &#34;  # Snort ID of the alert
        rule += &#34;rev:1; &#34;  # Revision of the alert
        rule += &#34;reference:url,https://misp.gsma.com/events/view/19270; &#34;  # Reference of the alert
        rule += &#34;)&#34;

        if verbose:
            print(rule)
        return rule

    def to_hex(self, domain: str) -&gt; str:
        &#34;&#34;&#34;
        Description:
            Convert a domain to hex format for snort rules

        Args:
            domain (str): Domain to be converted

        Returns:
            str: Hex representation of the domain
        &#34;&#34;&#34;
        return &#34; &#34;.join(f&#34;{ord(c):02x}&#34; for c in domain)

    def append_rule(self, data: dict):
        &#34;&#34;&#34;
        Description:
        Append rule to the local.rules

        Args:
            data (str): Data to be appended to the local.rules file
        &#34;&#34;&#34;

        # Right now this is just a simple implementation

        if (rule := self.rule_translator(data)) is None:
            return

        if self.rule_exists(rule):
            return

        # Backup the rules file
        self.file_backup()

        # Append the rule to the rules file
        with open(self.rules_file, &#34;a&#34;) as file:
            file.write(f&#34;\n{rule}\n&#34;)

    def rule_exists(self, rule):
        &#34;&#34;&#34;
        Description:
            Check if the rule already exists in the rules file
            This function reads the rules file line by line and determines if the
            provided rule is present in any of the lines. It is useful for avoiding
            duplicate entries in the rules file.

        Args:
            rule (str): Rule to be checked

        Returns:
            bool: True if the rule exists, False otherwise
        &#34;&#34;&#34;

        with open(self.rules_file, &#34;r&#34;) as file:
            rules = file.readlines()
            if any(rule in rule_line for rule_line in rules):
                return True
            return False</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fileagent.main.FileAgent" href="../main.html#fileagent.main.FileAgent">FileAgent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fileagent.managers.manager_snort.ManagerSnort.append_rule"><code class="name flex">
<span>def <span class="ident">append_rule</span></span>(<span>self, data: dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_rule(self, data: dict):
    &#34;&#34;&#34;
    Description:
    Append rule to the local.rules

    Args:
        data (str): Data to be appended to the local.rules file
    &#34;&#34;&#34;

    # Right now this is just a simple implementation

    if (rule := self.rule_translator(data)) is None:
        return

    if self.rule_exists(rule):
        return

    # Backup the rules file
    self.file_backup()

    # Append the rule to the rules file
    with open(self.rules_file, &#34;a&#34;) as file:
        file.write(f&#34;\n{rule}\n&#34;)</code></pre>
</details>
<div class="desc"><p>Description:
Append rule to the local.rules</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>Data to be appended to the local.rules file</dd>
</dl></div>
</dd>
<dt id="fileagent.managers.manager_snort.ManagerSnort.building_rule_alert"><code class="name flex">
<span>def <span class="ident">building_rule_alert</span></span>(<span>self, target: str, msg: str = None, verbose=False) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def building_rule_alert(self, target: str, msg: str = None, verbose=False) -&gt; str:
    rule = &#34;&#34;

    rule += f&#34;alert &#34;  # Start of the rule
    rule += &#34;ip &#34;
    rule += f&#34;{target} &#34;
    rule += &#34;any -&gt; $HOME_NET any &#34;  # Direction of the alert
    rule += &#34;(&#34;

    if msg:
        rule += f&#39;msg:&#34;{msg}&#34;; &#39;  # Message of the alert
    else:
        rule += f&#39;msg:&#34;IP Alert Incoming From IP {target}&#34;; &#39;

    rule += &#34;classtype:tcp-connection; &#34;  # Class type of the alert
    rule += &#34;sid:28154103; &#34;  # Snort ID of the alert
    rule += &#34;rev:1; &#34;  # Revision of the alert
    rule += &#34;reference:url,https://misp.gsma.com/events/view/19270; &#34;  # Reference of the alert
    rule += &#34;)&#34;

    if verbose:
        print(rule)
    return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fileagent.managers.manager_snort.ManagerSnort.building_rule_block"><code class="name flex">
<span>def <span class="ident">building_rule_block</span></span>(<span>self, target: str, msg: str = None, verbose=False) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def building_rule_block(self, target: str, msg: str = None, verbose=False) -&gt; str:
    rule = &#34;&#34;

    rule += f&#34;block &#34;  # Start of the rule
    rule += f&#34;http &#34;
    rule += f&#34;{target} &#34;
    rule += &#34;any -&gt; $HOME_NET any &#34;  # Direction of the alert
    rule += &#34;(&#34;

    if msg:
        rule += f&#39;msg:&#34;{msg}&#34;; &#39;  # Message of the alert
    else:
        rule += f&#39;msg:&#34;Block traffic From IP {target}&#34;; &#39;
    rule += &#34;)&#34;
    if verbose:
        print(rule)
    return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fileagent.managers.manager_snort.ManagerSnort.building_rule_block_domain"><code class="name flex">
<span>def <span class="ident">building_rule_block_domain</span></span>(<span>self, domain: str, msg: str = None, verbose=False) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def building_rule_block_domain(
    self, domain: str, msg: str = None, verbose=False
) -&gt; str:
    rule = &#34;&#34;
    rule += f&#34;block &#34;  # Start of the rule
    rule += &#34;ssl &#34;  # Protocol of the rule
    rule += &#34;any &#34;  # IP address of the rule
    rule += &#34;any &#34;  # Port of the rule
    rule += &#34;-&gt; &#34;  # Direction of the rule
    rule += &#34;$HOME_NET 443 &#34;  # Direction of the alert
    rule += &#34;(&#34;

    if msg:
        rule += f&#39;msg:&#34;{msg}&#34;; &#39;  # Message of the alert
    else:
        rule += f&#39;msg:&#34;Block domain {domain}&#34;; &#39;
    rule += f&#39;content:&#34;|{self.to_hex(domain)}|&#34;  ;&#39;  # Content of the alert
    rule += &#34;)&#34;

    if verbose:
        print(rule)
    return rule</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="fileagent.managers.manager_snort.ManagerSnort.get_ip_from_request"><code class="name flex">
<span>def <span class="ident">get_ip_from_request</span></span>(<span>self, request: dict) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ip_from_request(self, request: dict) -&gt; str:
    &#34;&#34;&#34;
    Description:
        Get the ip address from the request

    Args:
        request (dict): Request data to be checked for ip address

    Returns:
        str: The ip address from the request
    &#34;&#34;&#34;

    if request.get(&#34;content_type&#34;) == &#34;application/json&#34;:
        data = json.loads(request.get(&#34;content&#34;))
        return data.get(&#34;ip&#34;)
    elif request.get(&#34;content_type&#34;) == &#34;text/plain&#34;:
        return self.ip_matches(request.get(&#34;content&#34;))
    else:
        return None</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Get the ip address from the request</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>dict</code></dt>
<dd>Request data to be checked for ip address</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The ip address from the request</dd>
</dl></div>
</dd>
<dt id="fileagent.managers.manager_snort.ManagerSnort.ip_matches"><code class="name flex">
<span>def <span class="ident">ip_matches</span></span>(<span>self, data: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ip_matches(self, data: str) -&gt; str:
    &#34;&#34;&#34;
    Description:
        Check if the data contains an ip address. Checks for ipv4, ipv6 and url

    Args:
        data (str): Data to be checked for ip address

    Returns:
        str: the ip/url regex matching case
    &#34;&#34;&#34;
    ipv4_pattern = r&#34;\b(?:\d{1,3}\.){3}\d{1,3}\b&#34;
    ipv6_pattern = r&#34;\b(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}\b&#34;
    url_pattern = r&#34;\bhttps?://[^\s/$.?#].[^\s]*\b&#34;

    for pattern in [ipv4_pattern, ipv6_pattern, url_pattern]:
        match = re.search(pattern, data)
        if match:
            return match.group(0)
    return None</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Check if the data contains an ip address. Checks for ipv4, ipv6 and url</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>Data to be checked for ip address</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>the ip/url regex matching case</dd>
</dl></div>
</dd>
<dt id="fileagent.managers.manager_snort.ManagerSnort.rule_exists"><code class="name flex">
<span>def <span class="ident">rule_exists</span></span>(<span>self, rule)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rule_exists(self, rule):
    &#34;&#34;&#34;
    Description:
        Check if the rule already exists in the rules file
        This function reads the rules file line by line and determines if the
        provided rule is present in any of the lines. It is useful for avoiding
        duplicate entries in the rules file.

    Args:
        rule (str): Rule to be checked

    Returns:
        bool: True if the rule exists, False otherwise
    &#34;&#34;&#34;

    with open(self.rules_file, &#34;r&#34;) as file:
        rules = file.readlines()
        if any(rule in rule_line for rule_line in rules):
            return True
        return False</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Check if the rule already exists in the rules file
This function reads the rules file line by line and determines if the
provided rule is present in any of the lines. It is useful for avoiding
duplicate entries in the rules file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rule</code></strong> :&ensp;<code>str</code></dt>
<dd>Rule to be checked</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the rule exists, False otherwise</dd>
</dl></div>
</dd>
<dt id="fileagent.managers.manager_snort.ManagerSnort.rule_translator"><code class="name flex">
<span>def <span class="ident">rule_translator</span></span>(<span>self, data: dict) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rule_translator(self, data: dict) -&gt; str:
    &#34;&#34;&#34;
    Description:
        Translate the data into a rule
        Right now this is a simple implementation
        Checks if it is a json or text file and extracts the ip address

    Args:
        data (dict): Data from the post request to be translated into a rule,

    Returns:
        str: Rule to be appended to the rules file
    &#34;&#34;&#34;

    tranlator_book = {
        &#34;block_ip&#34;: self.building_rule_block,
        &#34;block_domain&#34;: self.building_rule_block_domain,
        &#34;alert_ip&#34;: self.building_rule_alert,
    }

    rule = None

    if (command := data.get(&#34;command&#34;)) in tranlator_book.keys():
        rule = tranlator_book[command](data.get(&#34;target&#34;))
    return rule</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Translate the data into a rule
Right now this is a simple implementation
Checks if it is a json or text file and extracts the ip address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Data from the post request to be translated into a rule,</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Rule to be appended to the rules file</dd>
</dl></div>
</dd>
<dt id="fileagent.managers.manager_snort.ManagerSnort.to_hex"><code class="name flex">
<span>def <span class="ident">to_hex</span></span>(<span>self, domain: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_hex(self, domain: str) -&gt; str:
    &#34;&#34;&#34;
    Description:
        Convert a domain to hex format for snort rules

    Args:
        domain (str): Domain to be converted

    Returns:
        str: Hex representation of the domain
    &#34;&#34;&#34;
    return &#34; &#34;.join(f&#34;{ord(c):02x}&#34; for c in domain)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Convert a domain to hex format for snort rules</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>domain</code></strong> :&ensp;<code>str</code></dt>
<dd>Domain to be converted</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hex representation of the domain</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fileagent.managers" href="index.html">fileagent.managers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fileagent.managers.manager_snort.ManagerSnort" href="#fileagent.managers.manager_snort.ManagerSnort">ManagerSnort</a></code></h4>
<ul class="">
<li><code><a title="fileagent.managers.manager_snort.ManagerSnort.append_rule" href="#fileagent.managers.manager_snort.ManagerSnort.append_rule">append_rule</a></code></li>
<li><code><a title="fileagent.managers.manager_snort.ManagerSnort.building_rule_alert" href="#fileagent.managers.manager_snort.ManagerSnort.building_rule_alert">building_rule_alert</a></code></li>
<li><code><a title="fileagent.managers.manager_snort.ManagerSnort.building_rule_block" href="#fileagent.managers.manager_snort.ManagerSnort.building_rule_block">building_rule_block</a></code></li>
<li><code><a title="fileagent.managers.manager_snort.ManagerSnort.building_rule_block_domain" href="#fileagent.managers.manager_snort.ManagerSnort.building_rule_block_domain">building_rule_block_domain</a></code></li>
<li><code><a title="fileagent.managers.manager_snort.ManagerSnort.get_ip_from_request" href="#fileagent.managers.manager_snort.ManagerSnort.get_ip_from_request">get_ip_from_request</a></code></li>
<li><code><a title="fileagent.managers.manager_snort.ManagerSnort.ip_matches" href="#fileagent.managers.manager_snort.ManagerSnort.ip_matches">ip_matches</a></code></li>
<li><code><a title="fileagent.managers.manager_snort.ManagerSnort.rule_exists" href="#fileagent.managers.manager_snort.ManagerSnort.rule_exists">rule_exists</a></code></li>
<li><code><a title="fileagent.managers.manager_snort.ManagerSnort.rule_translator" href="#fileagent.managers.manager_snort.ManagerSnort.rule_translator">rule_translator</a></code></li>
<li><code><a title="fileagent.managers.manager_snort.ManagerSnort.to_hex" href="#fileagent.managers.manager_snort.ManagerSnort.to_hex">to_hex</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
